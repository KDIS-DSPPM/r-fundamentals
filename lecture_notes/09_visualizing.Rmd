---
title: 'Visualizing'
author: "Jae Yeon Kim"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

# Setup 

```{r}
pacman::p_load(tidyverse, 
               gapminder, 
               nycflights13, 
               ggthemes,
               coronavirus, 
               babynames, 
               glue, 
               patchwork)
```

## Visualizing (ggplot2)

- The following material is adapted from Kieran Healy's excellent book (2019) on [data visualization](https://socviz.co/) and Hadley Wickham's equally excellent book on [ggplot2](https://ggplot2-book.org/). For more theoretical discussions, I recommend you to read [The Grammar of Graphics](https://link.springer.com/book/10.1007%2F0-387-28695-0) by Leland Wilkinson.

- Why should we care about data visualization? More precisely, why should we learn the grammar of statistical graphics?
- Sometimes, pictures are better tools than words in 1) exploring, 2) understanding, and 3) explaining data.

### Motivation 

[Anscombe](https://en.wikipedia.org/wiki/Frank_Anscombe)'s quarter comprises four datasets, which are so alike in terms of their descriptive statistics but quite different when presented graphically.

```{r}
# Set theme
theme_set(theme_minimal())
```

```{r}
# Data
anscombe
```

```{r}
# Correlation
cor(anscombe)[c(1:4), c(5:8)]
```

```{r}
# gather and select
anscombe_processed <- anscombe %>%
  gather(x_name, x_value, x1:x4) %>%
  gather(y_name, y_value, y1:y4)

# plot
anscombe_processed %>%
  ggplot(aes(x = x_value, y = y_value)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE) +
  facet_grid(x_name ~ y_name) +
  theme_bw() +
  labs(
    x = "X values",
    y = "Y values",
    title = "Anscombe's quartet"
  )
```

### The grammar of graphics 

- the grammar of graphics 

    - data
    - aesthetic attributes (color, shape, size)
    - geometric objects (points, lines, bars)
    - stats (summary stats)
    - scales (map values in the data space)
    - coord (data coordinates)
    - facet (facetting specifications)
    
No worries about new terms. We're going to learn them by actually plotting. 

- Workflow: 

    1. Tidy data 
    2. Mapping
    3. Geom 
    4. Corordinates and scales 
    5. Labels and guides
    6. Themes
    7. Save files 

### mapping and geom

- `aes` (aesthetic mappings or aesthetics) tells which variables (x, y) in your data should be represented by which visual elements (color, shape, size) in the plot.

- `geom_` tells the type of plot you are going to use 

### basic aes (x , y)

```{r}
gapminder
```

```{r}
p <- ggplot(
  gapminder,
  aes(x = gdpPercap, y = lifeExp)
) # ggplot or R in general takes positional arguments too. So, you don't need to name data, mapping each time you use ggplot2.
```

```{r}
p + geom_point()

p + geom_point() + 
    geom_smooth(method = "lm") # geom_smooth has calculated a smoothed line;
# the shaded area is the standard error for the line
```

```{r}
ggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +
    geom_point() +
    geom_smooth(method = "lm") +
    scale_x_log10() 
```

### Univariate distribution

- `geom_histogram()`: For the probability distribution of a continuous variable. Bins divide the entire range of values into a series of intervals (see [the Wiki entry](https://en.wikipedia.org/wiki/Histogram)). 
- `geom_density()`: Also for the probability distribution of a continuous variable. It calculates a [kernel density estimate](https://en.wikipedia.org/wiki/Kernel_density_estimation) of the underlying distribution. 

#### Histogram 

```{r}
data(midwest) # load midwest dataset

midwest
```

```{r, eval = FALSE}
midwest %>%
  ggplot(aes(x = area) +
  geom_point() # not working.
```

```{r}
midwest %>% # tidy data 
  ggplot(aes(x = area)) + # mapping
  geom_histogram(binwidth = 0.001) # stat_bin argument picks up 30 bins (or "bucket") by default.
```

```{r}
midwest %>%
  ggplot(aes(x = area)) +
  geom_histogram(bins = 10) # only 10 bins.

ggplot(
  data = subset(midwest, state %in% c("OH", "IN")),
  mapping = aes(x = percollege, fill = state)
) +
  geom_histogram(alpha = 0.8, bins = 20) +
  scale_fill_viridis_d()
```

#### Density 

```{r}
midwest %>%
  ggplot(aes(x = area, 
             fill = state, 
             color = state)) +
  geom_density(alpha = 0.3) 
  scale_color_viridis_d() +
  scale_fill_viridis_d()
```

### Advanced aes (size, color)

- There's also `fill` argument (mostly used in `geom_bar()`). Color `aes` affects the appearance of lines and points, fill is for the filled areas of bars, polygons, and in some cases, the interior of a smoother's standard error ribbon.

- The property size/color/fill represents... 

```{r}
ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp,
    size = pop
  )
) +
  geom_point()
```

```{r}
ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp,
    size = pop,
    color = continent
  )
) +
  geom_point() +
  scale_color_viridis_d()
```

```{r}
# try red instead of "red"
ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp,
    size = pop,
    color = "red"
  )
) +
  geom_point()
```

Aesthetics also can be mapped per Geom. 

```{r}
p <- ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp
  )
)

p + geom_point() +
  geom_smooth()

p + geom_point(alpha = 0.3) + # alpha controls transparency
    geom_smooth(color = "red", se = FALSE, size = 2)
```

```{r}
ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp
  )
) + geom_point(alpha = 0.3) + # alpha controls transparency
  geom_smooth(color = "red", se = FALSE, size = 2, method = "lm") +
  scale_x_log10() +
  scale_y_log10()
```

```{r}
gapminder
```

Your turn!!

1. Create a scatter (point) plot between pop and gdpPercap across countries.  

```{r}
gapminder %>%
    ggplot(aes(x = pop, y = gdpPercap, size = pop)) +
    geom_point()
```

```{r}
ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp,
    color = continent
  )
) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", color = "red") +
  labs(
    x = "log GDP",
    y = "Life Expectancy",
    title = "A Gapminder Plot",
    subtitle = "Data points are country-years",
    caption = "Source: Gapminder"
  )

ggplot(
  data = gapminder,
  mapping = aes(
    x = gdpPercap, y = lifeExp,
    color = continent,
    fill = continent
  )
) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", color = "red") +
  labs(
    x = "log GDP",
    y = "Life Expectancy",
    title = "A Gapminder Plot",
    subtitle = "Data points are country-years",
    caption = "Source: Gapminder"
  ) +
  scale_color_viridis_d() +
  scale_fill_viridis_d()
```

### Co-ordinates and scales 

```{r}
p + geom_point() +
  coord_flip() # coord_type
```

The data is heavily bunched up against the left side. 

```{r}
p + geom_point() # without scaling

plot1 <- p + geom_point() +
  scale_x_log10() # scales the axis of a plot to a log 10 basis

plot2 <- p + geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10()

library(patchwork)

plot1 + plot2 + patchwork::plot_annotation(tag_levels = c('A', '1'))
```


### Labels and guides 

`scales` package has some useful premade formatting functions. You can either load scales or just grab the function you need from the library using `scales::` 

```{r}
p + geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", color = "red") +
  scale_x_log10(labels = scales::dollar) +
  labs(
    x = "log GDP",
    y = "Life Expectancy",
    title = "A Gapminder Plot",
    subtitle = "Data points are country-years",
    caption = "Source: Gapminder"
  )
```

### Themes

```{r}
p + geom_point(alpha = 0.3) +
  geom_smooth(method = "loess", color = "red") +
  scale_x_log10(labels = scales::dollar) +
  labs(
    x = "log GDP",
    y = "Life Expectancy",
    title = "A Gapminder Plot",
    subtitle = "Data points are country-years",
    caption = "Source: Gapminder"
  ) +
  theme_wsj()
```

### ggsave 

```{r eval = FALSE}
figure_example <- p + geom_point(alpha = 0.3) +
  geom_smooth(method = "gam", color = "red") +
  scale_x_log10(labels = scales::dollar) +
  labs(
    x = "log GDP",
    y = "Life Expectancy",
    title = "A Gapminder Plot",
    subtitle = "Data points are country-years",
    caption = "Source: Gapminder"
  ) +
  theme_economist()

figure_example

ggsave(here("outputs", "figure_example.png"))
```

## Exercises

### Coronavirus

1. Calculate the total number of cases per each country and continent 

2. Display the information in 1 using scatter plot 

3. Change the scale of x and y axis using log transformation 

4. Create mini plots of the plot in 3 using `facet_wrap(~continent_name)`

5. Fit a linear model to these mini plots using `geom_smooth(method = "lm")`

```{r}
options(scipen = 100)

coronavirus %>%
    filter(country == "Korea, South") %>%
    filter(cases > 0) %>%
    filter(type == "confirmed") %>%
    ggplot(aes(x = date, y = cases)) +
    geom_line(alpha = 0.7, col = "red") +
    ggthemes::theme_base()
```

```{r}
options(scipen = 100)

coronavirus %>% 
    group_by(continent_name, country, population) %>%
    summarize(sum = sum(cases)) %>%
    filter(!is.na(continent_name)) %>%
    ggplot(aes(x = population, y = sum)) +
    geom_point() +
    scale_x_log10() +
    scale_y_log10() +
    geom_smooth(method = "lm") +
    facet_wrap(~continent_name) 
```

### Babynames

```{r}
babynames
```

Copied the following code from here: https://github.com/AbdoulMa/TidyTuesday/blob/main/2022_w12/tidytuesday_2022_w12.R

```{r}
popular_unisex_names <- c("Jessie","Marion","Jackie","Alva","Ollie",
                          "Jody","Cleo","Kerry","Frankie","Guadalupe",
                          "Carey","Tommie","Angel","Hollis","Sammie",
                          "Jamie","Kris","Robbie","Tracy","Merrill",
                          "Noel","Rene","Johnnie","Ariel","Jan",
                          "Devon","Cruz","Michel","Gale","Robin",
                          "Dorian","Casey","Dana","Kim","Shannon"
)


babynames_df <- babynames %>% 
  select(-prop) %>%
  filter(name %in% popular_unisex_names) %>% 
  filter(year > 1925)

unisex_babynames <- babynames_df %>% 
  pivot_wider(names_from = sex, values_from = n) %>% 
  drop_na(`F`,`M`) %>% 
  mutate(
    prop_f = `F`/(`F`+`M`), # Proportion of girls
    prop_m = `M`/(`F`+`M`) # Proportion of boys 
  )


# Compute Proportions distance Means for order names 
(most_unisex_props_means <-  unisex_babynames %>% 
    mutate(prop_dist = abs(prop_f-prop_m)) %>% 
    group_by(name) %>% 
    summarise(prop_dist_mean = mean(prop_dist)) %>% 
    mutate(rank = rank(prop_dist_mean)) %>% 
    arrange(rank))

# Order names by proortion distance means 
unisex_babynames <- unisex_babynames %>% 
  left_join(most_unisex_props_means, by = "name") %>% 
  mutate(
    name_ranked = glue("{rank}. {name}"),
    name_ranked = fct_reorder(name_ranked,rank)
  )

# Determine most unisex year for each name 
most_unisex_year <- unisex_babynames  %>% 
  mutate(prop_dist = abs(prop_f-prop_m)) %>% 
  group_by(name_ranked) %>% 
  slice_min(prop_dist,n=1, with_ties = F) %>% 
  ungroup() 

# Function for normalize between range ( I use that inside grobs for panels annotations )
range_between <-  function(x,range){ (x-min(range)) / (max(range)-min(range)) }

plot <- unisex_babynames %>%   
   ggplot(aes(year)) + 
   geom_ribbon(aes(ymin = 0, ymax = prop_f), fill = "#E3837D")+
   geom_ribbon(aes(ymin = prop_f, ymax = 1), fill = "#96CBFE")+
   geom_line(aes(y=prop_f), size = 0.35) +
   
   facet_wrap(~name_ranked, ncol = 7, scales ='free_x')+
   scale_x_continuous(
     name = NULL,
     breaks = c(1940,1960,1980,2000),
     labels = c(1940,"'60","'80",2000)
   )+
   scale_y_continuous(
     name = NULL, 
     breaks = c(0,0.5,1),
     labels = scales::percent
   )
```